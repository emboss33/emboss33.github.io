<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>포트폴리오 - 백종민</title>
    <!-- Google Fonts 적용 -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    
    <style>
        /* 전체 스타일 */
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #F8F9FA;
            margin: 0;
            padding: 0;
            color: #333;
        }

        .container {
            width: 80%;
            margin: auto;
            padding: 40px 20px;
        }

        h1 {
            color: #222;
            font-weight: 700;
            font-size: 28px;
        }

        h2 {
            color: #222;
            font-weight: 600;
            font-size: 22px;
        }

        p {
            font-size: 16px;
            line-height: 1.6;
        }

        /* 강조 텍스트 */
        .highlight {
            color: #007BFF;
            font-weight: bold;
        }

        /* 섹션 스타일 */
        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        /* Work Experience 스타일 */
        .experience {
            border-left: 4px solid #007BFF;
            padding-left: 15px;
            margin-bottom: 20px;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        ul li::before {
            content: "✔";
            color: #007BFF;
            font-weight: bold;
            margin-right: 8px;
        }

        /* Skills 섹션 스타일 */
        .skills-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .skill {
            background: #007BFF;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>백종민</h1>
            <p style="font-weight: 600; font-size: 18px;">풀스택 개발자 | AI & 웹 기술 활용</p>
        </header>

        <!-- About Me -->
        <section class="section">
            <h2>About Me</h2>
            <p>
                안녕하세요! 저는 AI 및 웹 기술을 활용해 <strong>창의적인 솔루션</strong>을 만드는 
                <strong>풀스택 개발자 백종민</strong>입니다.  
                개발자는 단순히 요구사항을 해결하는 것이 아니라,  
                <strong class="highlight">사용자의 관점에서 여러 번 시뮬레이션하며 최적의 결과를 도출하는 과정</strong>이 중요하다고 생각합니다.  
                <span class="highlight">신중에 신중을 기울이며 최적의 솔루션을 만들어가는 것</span>을 지향합니다.
            </p>
        </section>
        <section class="section">
            <h2>현재 하고있는 것</h2>
            <p>
                최근 AI 기술에 대한 관심이 높아지면서, 저도 <strong>Kotlin 기반의 프로젝트</strong>에  
                <strong>오픈소스 AI 모델</strong>을 직접 적용하는 방향으로 개발을 진행 중입니다.  
                외부 유료 API 없이도 충분한 성능을 구현할 수 있도록,  
                <span class="highlight">Hugging Face, Sentence Transformers, BART, T5</span> 등의 모델 구조와 논문을 분석하며  
                다양한 AI 기능을 프로토타입 형태로 실험하고 있습니다.
            </p>
            <p>
                초기에는 엣지 컴퓨팅을 중심으로 한 로컬 처리 구조를 구상했지만,  
                하드웨어 리소스의 한계로 인해 기능 제약이 발생하면서,  
                현재는 <strong>서버를 통한 RESTful API 형태의 AI 서비스 구조</strong>를 우선적으로 구축 중입니다.  
                이후 Kotlin 클라이언트와 연동하여, <span class="highlight">서버 + 엣지 하이브리드 구조</span>의 서비스를 구현하는 것이 최종 목표입니다.
            </p>
            <p>
                이처럼 하이브리드 구조를 통해, 서버의 부하를 줄이고  
                간단한 기능은 사용자 디바이스에서 직접 처리함으로써  
                <strong>네트워크 최적화 및 무료 기능 제공 가능성</strong>을 높일 수 있을 것이라 기대하고 있습니다.
            </p>
            <p>
                최신 AI 트렌드를 따라가기 위해, 관련 논문과 GitHub 프로젝트, 커뮤니티 등을 꾸준히 탐색하고 있으며,  
                단순한 기술 구현을 넘어서 <strong>사용자에게 진정한 가치를 제공할 수 있는 서비스</strong>를 만드는 데 집중하고 있습니다.
            </p>
        </section>

        <!-- Work Experience -->
        <section class="section">
            <h2>Work Experience</h2>
            <div class="experience">
                <h3>AI 융합 STT 글로벌 통역 채팅앱 (단독 개발)</h3>
                <p><strong>기간:</strong> 2024.09 ~ 2024.11</p>
                <p><strong>기술 스택:</strong> Node.js, MongoDB, React Native, GPT API, Redis,(Docker), JWT, Socket.IO, RESTful API, 소셜 로그인</p>
                <ul>
                    <li><strong class="highlight">React Native</strong>를 사용하여 모바일 앱 개발</li>
                    <li><strong class="highlight">node.js</strong>를 사용하여 서버 구축</li>
                    <li><strong class="highlight">GPT API</strong>를 활용한 AI 문장 교정 시스템 구축</li>
                    <li>FIFO 기법과 <strong class="highlight">Redis (Docker)</strong> 캐시를 활용한 사용자 처리 최적화</li>
                    <li><strong>JWT 인증 시스템</strong> (임시토큰 & 리프레시 토큰 활용)으로 보안 강화</li>
                    <li><strong class="highlight">Socket.IO</strong>를 통한 실시간 대화 지원 (DB와 사용자 검증)</li>
                    <li>로컬(외부 API 서버,JWT 서버, Database 서버,Redis 캐시 서버,Redis 메시지큐 서버),Public ( Socket 서버,Main)서버로 <strong>아키텍처 구축</strong></li>
                    <li>소켓 통신 안전성 강화 및 알림 서비스 구현</li>
                    <li>데이터 암호화 처리</li>
                    <li>각종 보안 알고리즘 적용 (DOSC,사용자 정보 위조,인가되지않은 접근 등)</li>
                </ul>
            </div>
        </section>

                <!-- Code Structure -->
                <section class="section">
                    <h2>Code Structure</h2>
                    <p>
                        혼자 개발하더라도 유지보수와 확장성을 고려하여 모듈화된 구조로 항상 구조화된 설계를 지향합니다
                        각 폴더는 <strong>역할별로 나뉘어 있으며</strong>, 기능 단위로 구분하여 개발하므로 협업과 유지보수를 항상 고려합니다.
                    </p>
                    
                    <pre style="background-color: #333; color: #fff; padding: 15px; border-radius: 8px; font-size: 14px; overflow-x: auto;">
        📂 src/
         ├── 📂 context/        # 데이터베이스 및 소켓 관련 컨텍스트 관리
         │   ├── databaseContext.js
         │   ├── SocketContext.js
         │
         ├── 📂 features/       # 주요 기능별 폴더
         │   ├── 📂 Chat/      # 채팅 관련 기능
                ├── 📂 components/      # 부분별 컴포넌트 인터페이스 모음
                ├── 📂 hooks/      # 백그라운드 로직 모음
                ├── 📂 Images/      # 이미지  모음                
                ├── 📂 styles/      # CSS  모음
                 ChatScreen.js # Main.js
         │   ├── 📂 Home/      # 홈 화면 기능
         │   ├── 📂 More (회원가입,로그인)                     
         │
         ├── 📂 navigation/     # 네비게이션 관리
         │   ├── AppNavigator.js
         │
         ├── 📂 services/       # API 호출, 데이터 처리, 인증
         │   ├── authService.js
         │   ├── databaseService.js
         │   ├── socketService.js
         │   ├── tokenService.js
         │   ├── More
                    </pre>
        
                    <p>
                        - <strong>context/</strong>: 소켓 및 데이터베이스 관련 상태 관리 (SocketContext, databaseContext)
                        <br>
                        - <strong>features/</strong>: 각 기능별 (Chat, Home,Regist,Login 등) 독립적인 모듈로 분리
                        <br>
                        - <strong>navigation/</strong>: React Navigation을 사용한 앱 내 라우팅 관리
                        <br>
                        - <strong>services/</strong>: API 요청, 소켓 서비스, 데이터베이스 핸들링을 담당
                    </p>
                </section>

        <!-- Troubleshooting -->
<!-- Troubleshooting -->
<section class="section">
    <h2>Troubleshooting & Key Decisions</h2>
    
    <h3>📌 파일 구조화를 하게 된 이유</h3>
    <p>
        프로젝트 초기에는 <strong>src 폴더</strong>에 모든 파일을 몰아넣고 개발을 진행하였습니다.  
        하지만 프로젝트 규모가 커지면서 파일 개수가 많아졌고, <span class="highlight">각 파일의 역할을 파악하는 데 시간이 많이 소요</span>되었습니다.  
        이에 따라 기능별로 폴더를 나누어 <strong>모듈화된 파일 구조</strong>를 만들었고, 유지보수성과 가독성이 크게 향상되었습니다.
    </p>

    <h3>📌 Redis를 도입하게 된 이유</h3>
    <p>
        초기에는 <strong>메모리</strong>에 방(room)별 연결 포인트를 저장하여 관리했지만,  
        <span class="highlight">메모리 사용량이 지속적으로 증가하고, 대량의 유저를 감당하기 어려울 것</span>이라는 문제가 발생했습니다.  
        이를 해결하기 위해 <strong>Redis</strong>를 도입하여 <strong>활성화된 방과 비활성화된 방을 효율적으로 관리</strong>하도록 개선하였습니다.
    </p>

    <h3>📌 GPT API 요청 관리 개선</h3>
    <p>
        초기에 GPT API를 <strong>One Key</strong> 방식으로 사용했지만,  
        <span class="highlight">동시에 많은 유저가 접근하면 Deadlock이 발생할 가능성</span>이 높아졌습니다.  
        이를 해결하기 위해 <strong>Redis 메시지 큐</strong>를 활용하여 요청을 순차적으로 처리하도록 개선하여  
        <strong>안정적인 API 호출</strong>이 가능하도록 최적화하였습니다.
    </p>

    <h3>📌 서버를 많이 나누게 된 이유</h3>
    <p>
        <strong>국가 서버 관리 경험</strong>을 바탕으로, <span class="highlight">서버의 역할을 분할하는 것이 필수적</span>이라고 판단하였습니다.  
        단일 서버에서 모든 기능을 처리하면 유지보수 및 디버깅이 어려워질 뿐만 아니라,  
        특정 서비스에 부하가 집중될 경우 전체 시스템이 영향을 받을 위험이 있었습니다.  
        따라서, <strong>유지보수성과 안정성을 높이기 위해 서버를 역할별로 분리</strong>하였습니다.
    </p>

    <h3>📌 서버 역할 분리의 핵심 이유</h3>
    <ul>
        <li>🔄 <strong>JWT 인증 서버</strong> → 인증 및 토큰 관리 전담</li>
        <li>📡 <strong>WebSocket 서버</strong> → 실시간 통신 처리</li>
        <li>💾 <strong>데이터베이스 서버</strong> → MongoDB 유저 데이터 관리 전담</li>
        <li>🔗 <strong>API 서버</strong> → 외부 GPT API 요청 처리</li>
        <li>📍 <strong>Redis 캐시 서버</strong> → 세션 및 채팅방 관리 최적화</li>
    </ul>

    <p>
        이를 통해 서버 간 역할이 명확해졌고, <strong>디버깅, 확장성, 유지보수</strong>가 훨씬 수월해졌습니다.  
        또한, 특정 서버에 문제가 발생하더라도 <strong>다른 서버에 영향을 최소화</strong>할 수 있도록 설계되었습니다.
    </p>
</section>

        <!-- Skills -->
        <section class="section">
            <h2>Skills</h2>
            <div class="skills-list">
                <span class="skill">React Native</span>
                <span class="skill">Node.js</span>
                <span class="skill">MongoDB</span>
                <span class="skill">외부 API 연동</span>
                <span class="skill">Redis (Docker)</span>
                <span class="skill">JWT 인증</span>
                <span class="skill">Socket.IO</span>
                <span class="skill">RESTful API</span>
                <span class="skill">TypeScript</span>
                <span class="skill">Firebase</span>
                <span class="skill">WebSocket 인증</span>
                <span class="skill">Redis Pub/Sub</span>
                <span class="skill">IP 차단 시스템</span>
                <span class="skill">Rate Limiting</span>
                <span class="skill">Microservices</span>
                <span class="skill">비동기 메시지 큐</span>
                <span class="skill">Axios</span>
            </div>
        </section>

                <!-- Project: RFID 수신기를 연동한 지도 앱 -->
        <section class="section">
            <h2>Project: RFID 수신기를 연동한 지도 앱</h2>
            <p><strong>기간:</strong> 2024.06 ~ 2024.08</p>
            <p>
                신호등 근처에 RFID 수신기를 설치하여, 블루투스 디바이스와 연동된 사용자가 접근하면  
                서버에서 데이터를 수집하고 사용자에 Google 지도 API를 통해 앱에 정보를 업데이트하는 시스템입니다.
                사용자가 수신기 근처를 지나갈 때 음성 안내 기능이 작동하여 안전을 도와줍니다.
            </p>

            <h3>📌 프로젝트 개요 및 맡은 역할</h3>
            <ul>
                <li>프레임워크: React Native</li>
                <li>서버: Node.js + Express + MySQL</li>
                <li>지도 서비스: Google Maps API</li>
                <li>거리 측정 알고리즘:Haversine 공식 활용</li>
                <li>데이터 연동: RFID 수신기가 신호를 감지하면 DB에 업데이트</li>
                <li>음성 안내:사용자 근처를 지날 때 Sound 파일 재생</li>
            </ul>

            <h3>🚀 주요 기능</h3>
            <ul>
                <li>🔵 RFID 수신기가 블루투스 디바이스 감지 시, 서버에 실시간 데이터 업데이트</li>
                <li>🗺️ Google 지도 API 연동으로 현재 위치 및 수신기 근처 정보 표시</li>
                <li>🔊 사운드 파일을 이용한 음성 안내 기능</li>
                <li>📍 Haversine 기법을 활용하여 정확한 거리 측정 및 방향 안내</li>
                <li>🔄 React Native 기반의 UI/UX 설계로 직관적인 사용자 경험 제공</li>
            </ul>

            <h3>⚙️ 사용된 기술</h3>
            <div class="skills-list">
                <span class="skill">React Native</span>
                <span class="skill">Node.js</span>
                <span class="skill">Express.js</span>
                <span class="skill">MySQL</span>
                <span class="skill">Google Maps API</span>
                <span class="skill">Bluetooth Integration</span>
                <span class="skill">Haversine Algorithm</span>
                <span class="skill">PYTHON</span>
            </div>
        </section>

                <!-- Project: Massive Traffic Optimization System (MTOS) -->
                <section class="section">
                    <h2>Project: Massive Traffic Optimization System (MTOS) - 단독</h2>
                    <p>
                        대규모 온라인 마케팅 자동화를 위한 트래픽 생성 및 검색 알고리즘 최적화 시스템을 구축하였습니다.  
                        온프레미스 서버 60대와 Docker 기반 가상머신 280대를 통합 관리하며 고성능 트래픽 분산 및 검색 알고리즘 최적화를 수행하였습니다.
                    </p>
        
                    <h3>📌 프로젝트 개요</h3>
                    <ul>
                        <li>기간: 2023년 11월 ~ 2024년 3월</li>
                        <li>환경: Ubuntu 서버, Docker 컨테이너, Bash 스크립트</li>
                        <li>구성: 온프레미스 서버 60대 + Docker 컨테이너 280대 통합 관리</li>
                        <li>보안: SSH Private Key 인증 및 IP 제한 적용</li>
                        <li>자동화: Bash 스크립트 및 Crontab 활용하여 컨테이너 자동 실행</li>
                        <li>검색 알고리즘 최적화:내부 컨테이너에서 Python 기반 알고리즘 적용</li>
                    </ul>
        
                    <h3>🚀 주요 기능</h3>
                    <ul>
                        <li>🌍 트래픽 생성 및 부하 테스트 - 다중 서버 및 컨테이너를 활용하여 트래픽 관리, 부하 최적화</li>
                        <li>🛠 Docker 컨테이너 280대 통합 관리 - 자동화된 스크립트를 통해 트래픽 분산 처리</li>
                        <li>🔒 보안 강화 - SSH Private Key 인증 및 IP 제한을 통해 컨테이너 접근 제어</li>
                        <li>⏳ Crontab & Bash 자동화 - 각 컨테이너가 특정 시간에 동작하도록 예약 실행</li>
                        <li>🧠 Python 기반 자동화 알고리즘 최적화</li>
                        <li>비인가 접근 차단 솔류션 자동화 알고리즘 </li>
                    </ul>
        
                    <h3>⚙️ 사용된 기술</h3>
                    <div class="skills-list">
                        <span class="skill">Ubuntu</span>
                        <span class="skill">Docker</span>
                        <span class="skill">Bash Script</span>
                        <span class="skill">Crontab</span>
                        <span class="skill">SSH Private Key</span>
                        <span class="skill">Python</span>
                        <span class="skill">네트워크 트래픽 분석</span>
                        <span class="skill">온라인 마케팅 자동화</span>
                        <span class="skill">서버 모니터링</span>
                    </div>
                </section>

    <!-- System Engineer Experience -->
<section class="section">
    <h2>System Engineer Experience</h2>
    <p><strong>기간:</strong> 2023.02 ~ 2023.09</p>
    <p>
        시스템 엔지니어로서 <strong>국가 기관 서버 유지보수 및 최적화</strong>를 수행하였습니다.  
        <span class="highlight">국가 서버 운영 및 유지보수</span> 를 하면서 각종 보안, 네트워크 처리 기술들에 중요성을 알게되었으며
        안정적인 서버 관리와 <strong>보안 강화를 위한 시스템 설계</strong>에 대한 정보 수집을 출장을 다니면서 습득하였습니다..
    </p>

    <h3>📌 주요 업무</h3>
    <ul>
        <li>🔧 <strong>국가 서버 유지보수</strong> 및 성능 모니터링</li>
        <li>🛠 <strong>리눅스 서버</strong> 환경에서의 네트워크 구축, 장비 설치</li>
        <li>⚙️ 로그 분석 </li>
        <li>🚀 <strong>서버 장애 대응</strong></li>
    </ul>

    <h3>⚙️ 사용된 기술</h3>
    <div class="skills-list">
        <span class="skill">Linux</span>
        <span class="skill">CentOS</span>
        <span class="skill">Ubuntu Server</span>
        <span class="skill">로그 분석</span>
    </div>
</section>

<!-- Conclusion -->
<section class="section">
    <h2>마치며</h2>
    <p>
        제가 개발을 시작하게 된 계기는 <strong>코로나 시국에서의 경제적 어려움</strong> 때문이었습니다. 그당시   
        전공만으로는 경제활동이 쉽지 않다고 판단하였고,  
        <span class="highlight">국가 취업 연계 프로그램</span>을 통해 처음 코딩을 배우게 되었습니다.
    </p>

    <p>
        하지만 단순히 생계를 위한 수단이었던 코딩은 점점 <strong>제 삶의 일부</strong>가 되었고,  
        <span class="highlight">새로운 세상을 창조하는 경험</span> 속에서 강한 영감을 얻고있습니다.  
        앞으로도 제가 개발한 서비스 안에서 사용자들이 소통하고,행복하면 좋겠습니다 

    <p>
        개발이라는것은  저에게 단순한 직업이 아니라, <span class="highlight">내 삶의 만족도를 올려주는 중요한 요소</span>로서
        앞으로도 저는 이와같은 영감을 바탕으로 개발을 이어갈 것이며,  
        <strong>더 많은 사용자들에게 제가 창조한 아름다운 세상을 보여주고 싶습니다 감사합니다.</strong>
    </p>
</section>
    </div>
</body>
</html>
